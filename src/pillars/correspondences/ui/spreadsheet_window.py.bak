# Spreadsheet Window - The Sovereign Tablet Editor.
# Main window hosting the spreadsheet view, formula bar, toolbar, and multi-sheet tab navigation. 

from PyQt6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QDockWidget,
    QToolBar, QMessageBox, QMenu, QToolButton, QStyle,
    QLineEdit, QInputDialog
)
from PyQt6.QtGui import QAction
from PyQt6.QtCore import Qt, QEvent, QSize

from .spreadsheet_view import SpreadsheetView, SpreadsheetModel
from .scroll_tab_bar import ScrollTabBar
from ..services.table_service import TableService

from pillars.correspondences.services.conditional_formatting import ConditionalRule
from shared.ui.virtual_keyboard import get_shared_virtual_keyboard
from shared.ui.theme import COLORS

# New Components
from .components.formula_bar import FormulaBarWidget
from .components.status_bar import SpreadsheetStatusBar
from ..services.spreadsheet_io import SpreadsheetIO
from .components.search_handler import SearchHandler
from .components.style_handler import StyleHandler
from .components.formula_wizard_handler import FormulaWizardHandler

class SpreadsheetWindow(QMainWindow):
    # The Sovereign Window.
    # Hosts the Grid and the Toolbar (commands).

    def __init__(self, table_id, name, content, service: TableService, parent=None):
        super().__init__(parent)
        # init logic.
        
        # Args:
        self.table_id = table_id
        self.service = service
        self.setWindowTitle(f"Emerald Tablet: {name}")
        self.resize(1200, 800)

        # 1. Data Migration & Model Setup
        self.models = []
        scrolls_data = []
        active_index = 0

        # Detect Format
        if "scrolls" in content:
            # New Format
            scrolls_data = content.get("scrolls", [])
            active_index = content.get("active_scroll_index", 0)
        else:
            # Legacy Format - Wrap in Single Scroll
            scrolls_data = [{
                "name": "Sheet1",
                "columns": content.get("columns", []),
                "data": content.get("data", []) or content.get("rows", []),
                "styles": content.get("styles", {})
            }]
            active_index = 0
            
        # Hydrate Models
        for scroll in scrolls_data:
            m = SpreadsheetModel(scroll)
            # Store name on the model for convenience? Or separate metadata?
            # Model doesn't natively store name, let's attach it.
            m.scroll_name = scroll.get("name", "Sheet") 
            self.models.append(m)
            
        if not self.models:
            # Fallback for empty
            m = SpreadsheetModel({"columns": [], "data": []})
            m.scroll_name = "Sheet1"
            self.models.append(m)

        # Ensure index range
        if active_index >= len(self.models): active_index = 0
        self.current_model_index = active_index
        self.model = self.models[active_index]

        # 2. View Setup
        self.view = SpreadsheetView(self)
        self.view.setModel(self.model)
        self.view.setShowGrid(False)

        # 2. Central Widget Layout
        # We need a container to hold the Formula Bar AND the View (Grid)
        self.container = QWidget()
        self.central_layout = QVBoxLayout(self.container)
        self.central_layout.setContentsMargins(0, 0, 0, 0)
        self.central_layout.setSpacing(0)
        
        # 2a. Formula Bar (Component)
        self.formula_bar_widget = FormulaBarWidget()
        self.formula_bar_widget.text_changed.connect(self._on_formula_text_edited)
        self.formula_bar_widget.return_pressed.connect(self._on_formula_return)
        
        # Connect Name Box if we moved it? 
        # Actually in the new component we didn't include Name Box logic.
        # Let's keep Name Box in Window for now, or move it to component in next pass.
        # For now, let's just add the component.
        
        # Note: The component is defined to just have fx label and editor.
        # We need to integrate the Name Box (which is still in Window logic).
        
        # Formula Area Container
        formula_area = QWidget()
        fb_layout = QHBoxLayout(formula_area)
        fb_layout.setContentsMargins(4, 4, 4, 4)
        fb_layout.setSpacing(4)
        
        # Name Box (e.g. A1) - Kept in Window for orchestrator access
        self.name_box = QLineEdit()
        self.name_box.setReadOnly(True)
        self.name_box.setFixedWidth(80) 
        self.name_box.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.name_box.setPlaceholderText("A1")
        self.name_box.setStyleSheet("font-weight: bold; padding-left: 4px; padding-right: 4px;")
        
        fb_layout.addWidget(self.name_box)
        fb_layout.addWidget(self.formula_bar_widget)
        
        self.central_layout.addWidget(formula_area)
        self.central_layout.addWidget(self.view)
        
        # Map old self.formula_bar to the new editor for compatibility
        # This allows existing methods like setText to work if we proxy it
        # or we just update the methods. Let's update the methods.
        self.formula_bar = self.formula_bar_widget
        
        # 2b. Scroll Tab Bar
        self.tab_bar = ScrollTabBar()
        self.central_layout.addWidget(self.tab_bar)
        
        # Populate Tabs
        for m in self.models:
            self.tab_bar.add_tab(m.scroll_name)
        self.tab_bar.set_current_index(self.current_model_index)
        
        # Connect Signals
        self.tab_bar.tab_added.connect(self._on_scroll_added)
        self.tab_bar.tab_changed.connect(self._on_scroll_changed)
        
        # Menu (Show all sheets)
        def _show_all_sheets_menu():
             names = [m.scroll_name for m in self.models]
             self.tab_bar.update_menu(names)
             self.tab_bar.btn_menu.showMenu()
        self.tab_bar.btn_menu.clicked.connect(_show_all_sheets_menu)

        self.setCentralWidget(self.container)
        
        # Connect Selection Sync
        self.view.selectionModel().currentChanged.connect(self._on_selection_changed)
        self.view.selectionModel().selectionChanged.connect(self._on_range_selection_changed)
        # Connect ONLY current model initialy
        self.model.dataChanged.connect(self._on_data_changed)
        
        # State for point-and-click references
        self._is_editing_formula = False
        self._ref_mode = True # True = Enter Mode (Arrows navigate), False = Edit Mode (Arrows cursor)
        self._edit_source_index = None # The index we are editing (e.g. A1) while clicking B2
        self._phantom_ref_cursor = None # Virtual cursor for arrow navigation (keeps editor open)
        
        # Track manual edits to detect '='
        self.formula_bar.textEdited.connect(self._on_formula_text_edited)
        
        # 3. Toolbar
        self._setup_toolbar()
        
        # 4. Keyboard Dock (Hidden by default)
        self._kb_dock = QDockWidget("Virtual Keyboard", self)
        self._kb_dock.setAllowedAreas(Qt.DockWidgetArea.BottomDockWidgetArea)
        self._kb_dock.setWidget(get_shared_virtual_keyboard(self))
        self._kb_dock.hide()
        self.addDockWidget(Qt.DockWidgetArea.BottomDockWidgetArea, self._kb_dock)
        
        # 5. Unify Workflow: Listen for inline editor
        self.view.editor_text_changed.connect(self._on_inline_text_edited)
        self.view.viewport().installEventFilter(self)
        
        # 6. Status Bar
        self.status_bar = SpreadsheetStatusBar()
        self.status_bar.zoom_changed.connect(self._on_zoom_changed)
        self.setStatusBar(self.status_bar) 

        # 7. Search Handler
        self.search_handler = SearchHandler(self)

        # 8. Style Handler
        self.style_handler = StyleHandler(self)

        # 9. Wizard Handler
        self.wizard_handler = FormulaWizardHandler(self)

    def _on_zoom_changed(self, value):
        # Scale = value / 100.0
        # If view supports proper scaling:
        # self.view.scale(scale, scale) # QTableView doesn't scale easily.
        # We might need to adjust font size or row/col sizes.
        # For V1, let's just update font size or ignore.
        # Actually SpreadsheetView inheritance from QTableView makes generic scaling hard.
        pass

    def show_status(self, message, timeout=0):
        # Proxy to our component
        self.status_bar.show_message(message, timeout)

    # Override standard statusBar() usage if possible or replace calls?
    # We can replace internal calls to self.status_bar.show_message using regex or manual replace.

    def eventFilter(self, source, event):
        # A. Mouse Click Logic (Existing + New: Click Editor -> Edit Mode)
        if source == self.view.viewport() and event.type() == QEvent.Type.MouseButtonPress:
             if self._is_editing_formula:
                # Calculate cell under mouse
                pos = event.pos()
                index = self.view.indexAt(pos)
                
                # Check if we clicked the cell we are editing (Source)
                is_source = (index == self._edit_source_index)
                
                if index.isValid() and not is_source:
                    # Insert Reference
                    self._insert_reference_manual(index)
                    return True
                
        # B. Key Press Logic (Navigation)
        # We listen on active_editor (which installed us as filter) OR the viewport?
        # Actually editor events come from editor source.
        if event.type() == QEvent.Type.KeyPress:
             # 1. Toggle Mode (Ctrl+E)
             if event.key() == Qt.Key.Key_E and event.modifiers() & Qt.KeyboardModifier.ControlModifier:
                 self._ref_mode = not self._ref_mode
                 # Force cursor update?
                 return True # Consume
                 
             # 2. Key Navigation (Arrows)
             if self._is_editing_formula and self._ref_mode:
                 if event.key() in (Qt.Key.Key_Up, Qt.Key.Key_Down, Qt.Key.Key_Left, Qt.Key.Key_Right):
                     self._handle_arrow_navigation(event.key())
                     return True # Swallow event (don't move cursor in text)

        # C. Click on Editor -> Disable Ref Mode (Switch to Edit)
        # Note: Editor is separate widget, so source check needed?
        # C. Click on Editor -> Disable Ref Mode (Switch to Edit)
        # Note: Editor is separate widget, so source check needed?
        if self.view.active_editor and source == self.view.active_editor:
             if event.type() == QEvent.Type.MouseButtonPress:
                 self._ref_mode = False

        return super().eventFilter(source, event)

    def _handle_arrow_navigation(self, key):
        # 
#         Moves the selection relative to the LAST inserted reference (or current selection).
#         And inserts/updates the reference in the formula.
        # 
        # 1. Determine Start Position
        # Use Phantom Cursor if exists, else start from Source (Current)
        start_index = self._phantom_ref_cursor if self._phantom_ref_cursor else self.view.currentIndex()
        if not start_index.isValid(): return
        
        row, col = start_index.row(), start_index.column()
        
        # 2. Calculate Delta
        if key == Qt.Key.Key_Up: row -= 1
        elif key == Qt.Key.Key_Down: row += 1
        elif key == Qt.Key.Key_Left: col -= 1
        elif key == Qt.Key.Key_Right: col += 1
        
        # 3. Boundary Check
        row = max(0, min(row, self.model.rowCount() - 1))
        col = max(0, min(col, self.model.columnCount() - 1))
        
        # 4. Move Virtual Cursor
        new_index = self.model.index(row, col)
        self._phantom_ref_cursor = new_index
        
        # 5. Insert Reference
        # This will trigger text update -> parser -> highlighting of new_index
        self._insert_reference_manual(new_index)
        
        # Note: We DO NOT call setCurrentIndex(new_index) because that would close the active editor.
        # The visual highlighting relies on the Formula Engine parsing the new text and drawing the Colored Box.

    def _on_inline_text_edited(self, text):
        # 
#         Called when user types in the inline cell editor.
#         Syncs to Formula Bar and triggers Reference Mode check.
        # 
        # 1. Sync Formula Bar (Just text, don't trigger its signals yet)
        self.formula_bar.blockSignals(True)
        self.formula_bar.setText(text)
        self.formula_bar.blockSignals(False)
        
        # 2. Check for Mode Switch (e.g. user typed '=')
        # We manually trigger the logic that normally watches formula bar
        self._on_formula_text_edited(text)
        
        # 3. Ensure we track this cell as the source
        if not self._edit_source_index:
             self._edit_source_index = self.view.currentIndex()
             
        # 4. Auto-Switch to Ref Mode on Operators
        if text and text[-1] in ('=', '+', '-', '*', '/', '(', ','):
            self._ref_mode = True
            self._phantom_ref_cursor = None # Reset virtual cursor to start from Source again

    def _insert_reference_manual(self, index):
        # 
#         Manually inserts a reference into:
#         1. The Formula Bar
#         2. The Active Inline Editor (if exists)
        # 
        def col_to_letter(col_idx):
            # 
#             Col to letter logic.
#             
#             Args:
#                 col_idx: Description of col_idx.
#             
            # 
            res = ""
            while col_idx >= 0:
                res = chr((col_idx % 26) + 65) + res
                col_idx = (col_idx // 26) - 1
            return res
            
        ref_str = f"{col_to_letter(index.column())}{index.row() + 1}"
        
        # Insert into Formula Bar
        # Strategy: Insert at cursor position.
        # But where is the cursor?
        # If inline editor is focused, we use its cursor.
        # If formula bar is focused, we use its cursor.
        
        target_widget = self.view.active_editor if self.view.active_editor else self.formula_bar
        
        cursor = target_widget.cursorPosition()
        text = target_widget.text()
        
        new_text = text[:cursor] + ref_str + text[cursor:]
        
        # Update both
        self.formula_bar.setText(new_text)
        if self.view.active_editor:
            self.view.active_editor.setText(new_text)
            self.view.active_editor.setCursorPosition(cursor + len(ref_str))
            
        # Update state
        # (Usually handled by textEdited, but we set programmatically)
        # We need to ensure coloring update happens
        # self._update_toolbar_state(current) # Not quite.
        # Just triggering a viewport update usually helps
        self.view.viewport().update()
        
    def _launch_formula_wizard(self):
        self.wizard_handler.launch()

    def _on_formula_return(self):
        # Triggered by Formula Bar 'Enter' or Wizard commit
        self._commit_formula()

    def _commit_formula(self):
        text = self.formula_bar.text()
        
        # Target: explicit edit source OR current selection
        target = self._edit_source_index if (self._is_editing_formula and self._edit_source_index) else self.view.currentIndex()
        
        # Reset State BEFORE changing selection/focus to prevent accidental formula appends
        self._is_editing_formula = False
        self._edit_source_index = None

        if target.isValid():
            self.model.setData(target, text, Qt.ItemDataRole.EditRole)
            # Restore selection to target (since clicking modified it)
            self.view.setCurrentIndex(target)
            self.view.setFocus()
        


    def _setup_toolbar(self):
        toolbar = QToolBar("Tablet Tools")
        icon_size = self.style().pixelMetric(QStyle.PixelMetric.PM_SmallIconSize)
        scaled_size = int(icon_size * 1.5)
        toolbar.setIconSize(QSize(scaled_size, scaled_size))
        self.addToolBar(toolbar)
        
        # --- File Operations ---
        act_save = QAction("ðŸ’¾ Save", self)
        act_save.triggered.connect(self._save_table)
        toolbar.addAction(act_save)
        
        toolbar.addSeparator()
        
        # --- History ---
        stack = self.model.undo_stack
        
        act_undo = stack.createUndoAction(self, "Undo")
        act_undo.setShortcut("Ctrl+Z")
        act_undo.setText("â†© Undo")
        toolbar.addAction(act_undo)
        
        act_redo = stack.createRedoAction(self, "Redo")
        act_redo.setShortcut("Ctrl+Shift+Z")
        act_redo.setText("â†ª Redo")
        toolbar.addAction(act_redo)
        
        act_find = QAction("ðŸ”", self)
        act_find.setToolTip("Find (Ctrl+F)")
        act_find.setShortcut("Ctrl+F")
        act_find.triggered.connect(lambda: self._launch_find_replace("find"))
        toolbar.addAction(act_find)
        
        act_replace = QAction("âœŽ", self)
        act_replace.setToolTip("Replace (Ctrl+H)")
        act_replace.setShortcut("Ctrl+H")
        act_replace.triggered.connect(lambda: self._launch_find_replace("replace"))
        toolbar.addAction(act_replace)
        
        toolbar.addSeparator()

        # --- Conditional Formatting ---
        btn_cond = QToolButton()
        btn_cond.setText("Cond")
        btn_cond.setToolTip("Conditional Formatting")
        btn_cond.setPopupMode(QToolButton.ToolButtonPopupMode.InstantPopup)
        menu_cond = QMenu(btn_cond)
        
        act_gt = QAction("Greater Than...", self)
        act_gt.triggered.connect(lambda: self._add_conditional_rule("GT"))
        menu_cond.addAction(act_gt)
        
        act_lt = QAction("Less Than...", self)
        act_lt.triggered.connect(lambda: self._add_conditional_rule("LT"))
        menu_cond.addAction(act_lt)
        
        act_contains = QAction("Text Contains...", self)
        act_contains.triggered.connect(lambda: self._add_conditional_rule("CONTAINS"))
        menu_cond.addAction(act_contains)
        
        menu_cond.addSeparator()
        
        act_clear_rules = QAction("Clear All Rules", self)
        act_clear_rules.triggered.connect(self._clear_conditional_rules)
        menu_cond.addAction(act_clear_rules)
        
        btn_cond.setMenu(menu_cond)
        toolbar.addWidget(btn_cond)

        toolbar.addSeparator()

        # --- Virtual Keyboard ---
        act_keyboard = QAction("âŒ¨ Keyboard", self)
        act_keyboard.setToolTip("Open Virtual Keyboard (Hebrew/Greek)")
        act_keyboard.triggered.connect(self._toggle_keyboard)
        toolbar.addAction(act_keyboard)

        toolbar.addSeparator()

        # --- Borders ---
        # Menu for border options
        btn_border = QToolButton()
        btn_border.setText("âŠž")
        btn_border.setToolTip("Borders")
        btn_border.setPopupMode(QToolButton.ToolButtonPopupMode.InstantPopup)
        toolbar.addWidget(btn_border)
        
        self.border_menu = QMenu(self)
        btn_border.setMenu(self.border_menu)
        
        # State for next border application
        self._border_settings = {
            "color": "#000000",
            "style": "solid", # solid, dash, dot
            "width": 1
        }
        
        # Apply Actions
        self.border_actions = []
        actions_data = [
            ("All Borders", "all"),
            ("No Borders", "none"),
            ("Outside Borders", "outside"),
            ("Top Border", "top"),
            ("Bottom Border", "bottom"),
            ("Left Border", "left"),
            ("Right Border", "right"),
        ]
        
        # Inline helper for simple apply
        def _set_border(type_):
            self._apply_borders(type_)
        
        for name, key in actions_data:
            act = QAction(name, self)
            act.triggered.connect(lambda checked, k=key: _set_border(k))
            self.border_menu.addAction(act)
            self.border_actions.append(act)
            
        self.border_menu.addSeparator()
        
        # Settings Actions (Color, Style, Width)
        self.border_style_actions = []
        
        act_color = QAction("Line Color...", self)
        act_color.triggered.connect(self.pick_border_color)
        self.border_menu.addAction(act_color)
        self.border_style_actions.append(act_color)
        
        style_menu = self.border_menu.addMenu("Line Style")
        self.border_style_menu = style_menu
        self.border_width_menu = self.border_menu.addMenu("Line Width")
        
        for s in ["solid", "dash", "dot"]:
            a = QAction(s.title(), self)
            # Use self.set_border_style directly
            a.triggered.connect(lambda checked, style=s: self.set_border_style(style))
            style_menu.addAction(a)
            
        for w in [1, 2, 3, 4, 5]:
            a = QAction(f"{w}px", self)
            a.triggered.connect(lambda checked, width=w: self.set_border_width(width))
            self.border_width_menu.addAction(a)

        # Pass to View
        self.view.set_border_ui(self.border_actions, [act_color], style_menu, self.border_width_menu)





    def _update_toolbar_state(self, index):
        # Renamed from old logic inside _on_selection_changed# 
        font = self.model.data(index, Qt.ItemDataRole.FontRole)
        if font:
            self.font_combo.blockSignals(True)
            self.font_combo.setCurrentFont(font)
            self.font_combo.blockSignals(False)
            
            self.size_spin.blockSignals(True)
            self.size_spin.setValue(font.pointSize())
            self.size_spin.blockSignals(False)
            
            self.act_bold.blockSignals(True)
            self.act_bold.setChecked(font.bold())
            self.act_bold.blockSignals(False)
            
            self.act_italic.blockSignals(True)
            self.act_italic.setChecked(font.italic())
            self.act_italic.blockSignals(False)
            
            self.act_underline.blockSignals(True)
            self.act_underline.setChecked(font.underline())
            self.act_underline.blockSignals(False)
        else:
             self.act_bold.setChecked(False)
             self.act_italic.setChecked(False)
             self.act_underline.setChecked(False)

    def _save_table(self):
        # Persist to Database (Multi-Scroll).# 
        try:
            # Serialize all scrolls
            scrolls_list = []
            for m in self.models:
                # model.to_json() returns {columns, data, styles}. We need to add name.
                json_data = m.to_json()
                json_data["name"] = getattr(m, "scroll_name", "Sheet")
                scrolls_list.append(json_data)
                
            final_content = {
                "format_version": "2.0",
                "active_scroll_index": self.current_model_index,
                "scrolls": scrolls_list
            }
            
            self.service.save_content(self.table_id, final_content)
            self.status_bar.show_message("Tablet saved successfully.", 3000)
        except Exception as e:
            QMessageBox.critical(self, "Save Failed", str(e))
            # import traceback
            # traceback.print_exc()
            
    # --- Formatting Helpers ---
    # --- Formatting Logic delegated to StyleHandler ---

    def _on_selection_changed(self, current, previous):
        # Updates formula bar and Name Box (unless editing).# 
        # Always update Name Box
        if current.isValid():
            def col_to_letter(col_idx):
                # 
#                 Col to letter logic.
#                 
#                 Args:
#                     col_idx: Description of col_idx.
#                 
                # 
                res = ""
                while col_idx >= 0:
                    res = chr((col_idx % 26) + 65) + res
                    col_idx = (col_idx // 26) - 1
                return res
            addr = f"{col_to_letter(current.column())}{current.row() + 1}"
            self.name_box.setText(addr)
        else:
            self.name_box.setText("")

        # Formatting update
        self._update_toolbar_state(current)
        
        # Force redraw to clear artifacts
        self.view.viewport().update()

        if self._is_editing_formula:
            return

        if current.isValid():
            val = self.model.data(current, Qt.ItemDataRole.EditRole)
            self.formula_bar.blockSignals(True)
            self.formula_bar.setText(str(val) if val is not None else "")
            self.formula_bar.blockSignals(False)
            
    def _on_range_selection_changed(self, selected, deselected):
        # 
#         If in formula edit mode, inserting range references.
        # 
        if not self._is_editing_formula:
            return
            
        indexes = self.view.selectionModel().selectedIndexes()
        if not indexes: return

        # 1. Calculate Range String
        min_row = min(idx.row() for idx in indexes)
        max_row = max(idx.row() for idx in indexes)
        min_col = min(idx.column() for idx in indexes)
        max_col = max(idx.column() for idx in indexes)
        
        def col_to_letter(col_idx):
            # 
#             Col to letter logic.
#             
#             Args:
#                 col_idx: Description of col_idx.
#             
            # 
            res = ""
            while col_idx >= 0:
                res = chr((col_idx % 26) + 65) + res
                col_idx = (col_idx // 26) - 1
            return res
            
        start_addr = f"{col_to_letter(min_col)}{min_row + 1}"
        if min_row == max_row and min_col == max_col:
            ref_str = start_addr
        else:
            end_addr = f"{col_to_letter(max_col)}{max_row + 1}"
            ref_str = f"{start_addr}:{end_addr}"
        
        # 2. Insert into Formula Bar
        cursor = self.formula_bar.cursorPosition()
        text = self.formula_bar.text()
        
        # Simple Insert
        # Ideally we replace the previous ref if we are "drag-updating", but simple insert is safer for V1.
        # But wait, if I drag A1:B2, standard excel updates the ONE ref.
        # Without tokenizer state, that's hard.
        # Let's just assume the user wants to Insert.
        
        new_text = text[:cursor] + ref_str + text[cursor:]
        self.formula_bar.setText(new_text)
        self.formula_bar.setCursorPosition(cursor + len(ref_str))
        
        # Return focus to bar
        self.formula_bar.setFocus()

    def _on_formula_text_edited(self, text):
        # Detect if user is starting a formula.# 
        if text.startswith("="):
            if not self._is_editing_formula:
                # Enter Edit Mode
                self._is_editing_formula = True
                self._edit_source_index = self.view.currentIndex()
        else:
            if self._is_editing_formula and not text.startswith("="):
                self._is_editing_formula = False
                self._edit_source_index = None



    def _on_scroll_added(self):
        # Create a new scroll.# 
        new_name, ok = QInputDialog.getText(self, "New Scroll", "Scroll Name:", text="Sheet")
        if not ok or not new_name: return
        
        content = self._create_default_content()
        m = SpreadsheetModel(content)
        m.scroll_name = new_name
        
        self.models.append(m)
        self.tab_bar.add_tab(new_name)
        
        # Switch to it
        self.tab_bar.set_current_index(len(self.models) - 1)
        
    def _on_scroll_changed(self, index):
        # Switch the active view model.# 
        if index < 0 or index >= len(self.models): return
        
        # 1. Disconnect old
        try: self.model.dataChanged.disconnect(self._on_data_changed)
        except: pass
        
        # 2. Switch
        self.current_model_index = index
        self.model = self.models[index]
        self.view.setModel(self.model)
        
        # 3. Connect new
        self.model.dataChanged.connect(self._on_data_changed)
        
        # 4. Refresh UI State
        # Ensure we don't have invalid selection
        self.view.clearSelection()
        self._update_toolbar_state(self.view.currentIndex())
        self.name_box.setText("")
        self.formula_bar.setText("")
        
    def _create_default_content(self):
        # 26 Columns (A-Z)
        cols = [chr(65 + i) for i in range(26)]
        # 100 empty rows of similar width
        # Data format is list of lists
        data = [["" for _ in cols] for _ in range(100)]
        return {
            "columns": cols,
            "data": data,
            "styles": {}
        }

    def _on_data_changed(self, top_left, bottom_right, roles=None):
        # 
#         If the data in the currently selected cell changes (e.g. via inline edit), 
#         update the formula bar to reflect it.
        # 
        current = self.view.currentIndex()
        if not current.isValid():
            return
            
        # Check if current index is within the changed range
        if (top_left.row() <= current.row() <= bottom_right.row() and 
            top_left.column() <= current.column() <= bottom_right.column()):
            
            # Update Formula Bar
            raw_data = str(self.model.data(current, Qt.ItemDataRole.EditRole) or "")
            if self.formula_bar.text() != raw_data:
                self.formula_bar.blockSignals(True)
                self.formula_bar.setText(raw_data)
                self.formula_bar.blockSignals(False)

    # --- Border Settings Methods (Instance) ---
    # --- Border Logic delegated to StyleHandler ---
    def _toggle_keyboard(self):
        # Toggle Virtual Keyboard in/out.# 
        if self._kb_dock.isVisible():
            self._kb_dock.hide()
        else:
            self._kb_dock.show()

    def _sort_selection(self, ascending=True):
        # Sorts selection based on active cell column.# 
        selection = self.view.selectionModel()
        if not selection.hasSelection():
            # If nothing selected, maybe select used range?
            # Or assume user wants to sort used range?
            # For safety, require selection or single cell expands to used range?
            # Let's require selection for now to be safe.
            return
            
        indexes = selection.selectedIndexes()
        if not indexes: return
        
        # Calculate Bounding Rect
        rows = [i.row() for i in indexes]
        cols = [i.column() for i in indexes]
        
        top, bottom = min(rows), max(rows)
        left, right = min(cols), max(cols)
        
        # Sort Key: Active Cell Column
        # If active cell is outside range (possible with Ctrl+Click), default to Left column.
        current = self.view.currentIndex()
        key_col = current.column()
        
        if key_col < left or key_col > right:
            key_col = left
            
        self.model.sort_range(top, left, bottom, right, key_col, ascending)
        
    def _add_conditional_rule(self, rule_type):
        # Adds a conditional rule to the selected range.# 
        selection = self.view.selectionModel()
        if not selection.hasSelection(): return

        # 1. Ask for Value
        label = "Value:"
        if rule_type == "GT": label = "Greater Than:"
        if rule_type == "LT": label = "Less Than:"
        if rule_type == "CONTAINS": label = "Text Contains:"
        
        val_str, ok = QInputDialog.getText(self, "Conditional Rule", label)
        if not ok or not val_str: return
        
        # 2. Ask for Color (Simple for now: Default Red, or ask?)
        # Default: Light Red Fill + Dark Red Text (Theme Aligned)
        style = {"bg": COLORS['destroyer_disabled'], "fg": COLORS['destroyer']}
        
        # 3. Calculate Ranges
        indexes = selection.selectedIndexes()
        rows = [i.row() for i in indexes]
        cols = [i.column() for i in indexes]
        # Bounding box is safest for rule storage, though irregular selection possible.
        # We store bounding box for now.
        t, b = min(rows), max(rows)
        l, r = min(cols), max(cols)
        
        rule = ConditionalRule(
            rule_type=rule_type,
            value=val_str,
            format_style=style,
            ranges=[(t, l, b, r)]
        )
        
        # 4. Add to Manager
        if hasattr(self.model, "conditional_manager"):
            self.model.conditional_manager.add_rule(rule)
            # Repaint
            self.view.viewport().update()
            
            # Repaint
            self.view.viewport().update()
            
    def _clear_conditional_rules(self):
        # Removes all conditional formatting rules.# 
        if hasattr(self.model, "conditional_manager"):
            self.model.conditional_manager.clear_all_rules()
            self.view.viewport().update()
            self.status_bar.show_message("Cleared all Conditional Formatting rules.", 3000)




    def _export_csv(self):
        SpreadsheetIO.export_csv(self, self.model)

    def _export_json(self):
        SpreadsheetIO.export_json(self, self.model)

    def _export_image(self):
        SpreadsheetIO.export_image(self, self.view)

    def _import_csv(self):
        SpreadsheetIO.import_csv(self, self.model)

    # --- Find & Replace ---



    def _launch_find_replace(self, mode="find"):
        self.search_handler.launch(mode)

    # --- Search Logic moved to SearchHandler ---

        # 7. Search Handler
        self.search_handler = SearchHandler(self)
        
        # 8. Style Handler
        self.style_handler = StyleHandler(self)
        
        # 9. Wizard Handler
        self.wizard_handler = FormulaWizardHandler(self)
        
        # Setup UI
        self._setup_ui()
        self._setup_toolbar() 
        # Note: _setup_toolbar now needs to pull menu from StyleHandler
        