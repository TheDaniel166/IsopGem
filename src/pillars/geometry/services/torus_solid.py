"""Torus solid math utilities and calculator."""
from __future__ import annotations

import math
from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple

from ..shared.solid_payload import SolidLabel, SolidPayload
from .solid_geometry import Vec3, edges_from_faces
from .solid_property import SolidProperty


@dataclass(frozen=True)
class TorusMetrics:
    """
    Torus Metrics class definition.
    
    """
    major_radius: float
    minor_radius: float
    ratio: float
    surface_area: float
    volume: float
    major_circumference: float
    minor_circumference: float


@dataclass(frozen=True)
class TorusSolidResult:
    """
    Torus Solid Result class definition.
    
    """
    payload: SolidPayload
    metrics: TorusMetrics


@dataclass
class TorusMeshConfig:
    """
    Torus Mesh Config class definition.
    
    """
    major_segments: int = 40
    minor_segments: int = 20


class TorusSolidService:
    """Generates payloads for torus solids."""

    @staticmethod
    def build(major_radius: float = 3.0, minor_radius: float = 1.0, config: TorusMeshConfig = None) -> TorusSolidResult:
        """
        Build logic.
        
        Args:
            major_radius: Description of major_radius.
            minor_radius: Description of minor_radius.
            config: Description of config.
        
        Returns:
            Result of build operation.
        """
        if major_radius <= 0 or minor_radius <= 0:
            raise ValueError("Radii must be positive")
            
        if config is None:
            config = TorusMeshConfig()

        metrics = TorusSolidService._compute_metrics(major_radius, minor_radius)
        
        vertices, faces = TorusSolidService._generate_mesh(major_radius, minor_radius, config)
        edges = edges_from_faces(faces)
        
        # Labels usually at center or strategic points
        labels = [
            SolidLabel(text=f"R = {major_radius:.2f}", position=(major_radius, 0.0, -minor_radius * 1.5)),
            SolidLabel(text=f"r = {minor_radius:.2f}", position=(major_radius + minor_radius, 0.0, 0.0)),
        ]

        payload = SolidPayload(
            vertices=vertices,
            edges=edges,
            faces=faces,
            labels=labels,
            metadata={
                'major_radius': metrics.major_radius,
                'minor_radius': metrics.minor_radius,
                'surface_area': metrics.surface_area,
                'volume': metrics.volume,
            },
            suggested_scale=major_radius + minor_radius,
        )
        return TorusSolidResult(payload=payload, metrics=metrics)

    @staticmethod
    def _compute_metrics(R: float, r: float) -> TorusMetrics:
        """
        Compute all geometric metrics for a torus from major and minor radii.

        DERIVATIONS:
        ===========

        Parametric Definition:
        ----------------------
        A torus is the surface of revolution generated by revolving a circle
        of radius r (minor radius) around an axis at distance R (major radius)
        from the circle's center.

        Standard Parameterization:
        x(u,v) = (R + r·cos(v))·cos(u)
        y(u,v) = (R + r·cos(v))·sin(u)
        z(u,v) = r·sin(v)

        Where:
        - u ∈ [0, 2π]: angle around the major axis (toroidal direction)
        - v ∈ [0, 2π]: angle around the minor circle (poloidal direction)
        - R > 0: major radius (distance from center to tube center)
        - r > 0: minor radius (tube radius)

        Topology:
        ---------
        - Genus: g = 1 (one "hole")
        - Euler Characteristic: χ = V - E + F = 0
        - Fundamental Group: π₁(T²) = ℤ × ℤ (two independent loops)
        - Homeomorphic to: S¹ × S¹ (product of two circles)

        AHA MOMENT #1: GENUS-1 TOPOLOGY - THE FIRST HOLE
        =================================================
        The torus has Genus 1—it has EXACTLY ONE HOLE. This makes it the
        SIMPLEST non-trivial surface in topology!
        
        Genus progression:
        - Genus 0: Sphere (no holes) — topologically trivial
        - Genus 1: Torus (one hole) — first non-trivial surface
        - Genus 2: Double torus (two holes) — and so on...
        
        The torus is the FUNDAMENTAL BUILDING BLOCK of surface topology.
        Every closed orientable surface is a sphere with g handles = g tori
        glued on. The torus is the ATOM of topological surfaces.
        
        Euler Characteristic: χ = 2 - 2g
        - Sphere (g=0): χ = 2
        - Torus (g=1): χ = 0 ← The first surface with ZERO characteristic!
        - Double torus (g=2): χ = -2
        
        χ = 0 means the torus is perfectly BALANCED between positive
        curvature (sphere-like, χ>0) and negative curvature (saddle-like, χ<0).
        It is the EQUILIBRIUM FORM—neither expanding nor contracting.
        
        This is why the torus appears everywhere in physics: it represents
        STABLE EQUILIBRIUM. Phase spaces of oscillators, compactified
        dimensions in string theory, plasma confinement—all use the torus
        as the geometry of eternal circulation.

        Surface Area:
        -------------
        Method 1 (Surface of Revolution):
        For a surface of revolution around z-axis:
        A = 2π ∫ r(z)·√(1 + (dr/dz)²) dz

        For torus, the generating circle has parametric form:
        x = R + r·cos(θ), z = r·sin(θ)
        Arc length element: ds = r·dθ
        Circumference at height z: C(θ) = 2π(R + r·cos(θ))

        A = ∫₀²π 2π(R + r·cos(θ))·r dθ
          = 2πr ∫₀²π (R + r·cos(θ)) dθ
          = 2πr [Rθ + r·sin(θ)]₀²π
          = 2πr [2πR + 0]
          = 4π²Rr ✓

        Method 2 (Parameterization Surface Integral):
        A = ∫∫ |∂r/∂u × ∂r/∂v| du dv

        Position vector: r(u,v) = ((R+r·cos(v))·cos(u), (R+r·cos(v))·sin(u), r·sin(v))

        ∂r/∂u = (-(R+r·cos(v))·sin(u), (R+r·cos(v))·cos(u), 0)
        ∂r/∂v = (-r·sin(v)·cos(u), -r·sin(v)·sin(u), r·cos(v))

        |∂r/∂u × ∂r/∂v| = r(R + r·cos(v))

        A = ∫₀²π ∫₀²π r(R + r·cos(v)) dv du
          = r ∫₀²π [Rv + r·sin(v)]₀²π du
          = r ∫₀²π 2πR du
          = 2πRr ∫₀²π du
          = 4π²Rr ✓

        **Formula: A = 4π²Rr**

        Numerical: A ≈ 39.478 R·r (for π² ≈ 9.8696)

        AHA MOMENT #2: SURFACE OF REVOLUTION - PAPPUS'S THEOREM
        ========================================================
        The torus is the perfect demonstration of PAPPUS'S CENTROID THEOREMS—
        one of the most elegant results in classical geometry!
        
        Pappus's First Theorem (Surface Area):
        When a curve is revolved around an external axis, the surface area
        equals the arc length times the distance traveled by its centroid.
        
        For torus:
        - Generating circle: arc length = 2πr
        - Centroid travels: 2πR (full circle at radius R)
        - Surface area: (2πr) × (2πR) = 4π²Rr ✓
        
        Pappus's Second Theorem (Volume):
        When a plane region is revolved, the volume equals the area times
        the distance traveled by its centroid.
        
        For torus:
        - Circle area: πr²
        - Centroid travels: 2πR
        - Volume: (πr²) × (2πR) = 2π²Rr² ✓
        
        Both formulas derived INSTANTLY without calculus!
        
        This reveals the torus as the ARCHETYPAL surface of revolution—
        it embodies the principle of circular motion generating 3D form.
        Every rotation of a circle around an axis creates a torus family:
        - R >> r: thin ring (Saturn's rings)
        - R = r: horn torus (inner equator → point)
        - R < r: spindle torus (self-intersecting)
        - R → ∞: cylinder (torus stretched to infinity)
        
        The torus is the TEMPLATE for all surfaces of revolution.

        Volume:
        -------
        Method 1 (Pappus's Centroid Theorem):
        When a plane region is revolved around an external axis,
        the volume equals the area of the region times the distance
        traveled by its centroid.

        - Generating circle: area = πr²
        - Centroid travels distance: 2πR (full circle at radius R)
        - V = πr² × 2πR = 2π²Rr² ✓

        Method 2 (Cylindrical Shells):
        Consider horizontal slices at height z.
        At height z = r·sin(v), the shell has:
        - Inner radius: R - r·cos(v)
        - Outer radius: R + r·cos(v)
        - Thickness: dz = r·cos(v) dv

        Volume element: dV = π[(R+r·cos(v))² - (R-r·cos(v))²]·dz
                           = π[4Rr·cos(v)]·r·cos(v) dv
                           = 4πRr²·cos²(v) dv

        V = ∫₀²π 4πRr²·cos²(v) dv
          = 4πRr² ∫₀²π (1 + cos(2v))/2 dv
          = 4πRr² × π
          = 2π²Rr² ✓

        Method 3 (Triple Integration):
        V = ∫∫∫ r(R + r·cos(v)) du dv dρ
        where ρ ∈ [0, r] is radial coordinate in tube cross-section.

        After integration: V = 2π²Rr² ✓

        **Formula: V = 2π²Rr²**

        Numerical: V ≈ 19.739 R·r² (for π² ≈ 9.8696)

        Key Ratios:
        -----------
        **Aspect Ratio**: R/r
        - R/r < 1: "Self-intersecting" (spindle torus)
        - R/r = 1: "Horn torus" (inner equator contracts to point)
        - R/r > 1: "Ring torus" (standard torus with hole)
        - R/r → ∞: Approaches cylinder

        **Surface-to-Volume Ratio**: A/V = 2/r
        (Independent of major radius R!)

        AHA MOMENT #3: THE R/r RATIO - SHAPE METAMORPHOSIS
        ===================================================
        The ratio R/r (major radius / minor radius) determines the ENTIRE
        FAMILY of toroidal forms—from self-intersecting spindles to infinite
        cylinders!
        
        The Shape Spectrum:
        
        R/r = 0 (R=0): Sphere of radius r (degenerate case)
        R/r < 1: SPINDLE TORUS (self-intersecting)
          - Inner surface passes through itself
          - Two "lobes" meet at equator
          - Impossible to realize physically without self-penetration
          - Appears in topology/differential geometry as limiting case
        
        R/r = 1: HORN TORUS (critical point)
          - Inner equator contracts to a SINGLE POINT (cusp)
          - Gaussian curvature → ∞ at the cusp
          - Transition between spindle and ring
          - Like a sphere with a dimple that reaches the center
        
        R/r > 1: RING TORUS (standard form)
          - Clear central hole
          - All curvatures finite and smooth
          - The familiar "donut" shape
          - Most physical realizations live here
        
        R/r → ∞: CYLINDER (limit)
          - Hole radius R → ∞
          - Curvature becomes constant (cylindrical)
          - Torus "unrolls" into infinite cylinder
          - T² degenerates to S¹ × ℝ
        
        The R/r ratio is the CONTROL PARAMETER for the torus family.
        Every value generates a distinct geometric form, yet all are
        topologically equivalent (genus 1, χ=0)!
        
        This demonstrates a profound principle: TOPOLOGY (genus) is invariant
        under continuous deformation, but GEOMETRY (curvature, shape) varies
        infinitely. The torus family is a one-parameter manifold of shapes
        with identical topology.
        
        Physical Significance:
        - R/r = 1.5-3: Human blood cells (toroidal red blood cells in disease)
        - R/r = 2-10: Tokamak fusion reactors (plasma confinement)
        - R/r = 5-20: Vortex rings (smoke rings, dolphin bubble rings)
        - R/r >> 1: Saturn's rings, accretion disks (astrophysics)

        Curvatures:
        -----------
        **Gaussian Curvature**:
        K(u,v) = cos(v) / [r(R + r·cos(v))]

        - K > 0 on outer half (elliptic, sphere-like)
        - K < 0 on inner half (hyperbolic, saddle-like)
        - K = 0 at v = π/2, 3π/2 (parabolic, top/bottom circles)

        Total Gaussian curvature: ∫∫ K dA = 0 (genus 1 → χ = 0)

        **Mean Curvature**:
        H(u,v) = (R + 2r·cos(v)) / [2r(R + r·cos(v))]

        HERMETIC NOTE - THE OUROBOROS:
        ==============================
        The torus represents the **ETERNAL RETURN**, the **COSMIC CYCLE**:

        - **Circular Structure**: No beginning, no end
        - **Self-Sustaining**: Genus-1 topology = single continuous surface
        - **Dual Cycles**: Major circle (u) and minor circle (v) = macrocosm/microcosm
        - **Ouroboros**: The serpent eating its tail, symbol of eternity

        Symbolism:
        - **Major radius R**: The cosmic orbit, the path of manifestation
        - **Minor radius r**: The individual soul's cycle, the tube of life
        - **Ratio R/r**: The relationship between universal and personal
        - **Genus 1**: Unity through duality (one hole = two loops)

        In Mystical Traditions:
        - **Hermetic**: "As above, so below" (u-loop ↔ v-loop correspondence)
        - **Vedic**: Samsara (wheel of rebirth), eternal return
        - **Alchemical**: The circulatio (circular distillation of prima materia)
        - **Buddhist**: The wheel of dharma, endless cycles of existence

        The torus is the **perfect symbol of feedback**, where output becomes input,
        end becomes beginning. In modern terms: the phase space of oscillators,
        the attractor of periodic systems.

        Notable Properties:
        -------------------
        1. **Flat Torus**: In intrinsic geometry, can be "unrolled" to flat rectangle
        2. **Clifford Torus**: Special embedding in S³ (4D sphere) with equal radii
        3. **Minimal Surfaces**: No (unlike sphere), but close approximations exist
        4. **Möbius Strip**: Cut torus along longitude → cylinder; twist → Möbius
        5. **Two Circles Product**: Topologically T² = S¹ × S¹
        6. **Heegaard Splitting**: T² splits S³ into two solid tori

        Mathematical Curiosities:
        -------------------------
        • **Villarceau Circles**: Any torus contains two families of tangent circles
        • **Dupin Cyclides**: Torus is special case (R = r gives horn torus)
        • **Conformal Maps**: Torus admits flat metric (locally Euclidean)
        • **Modular Forms**: Torus → elliptic curves → modular arithmetic
        • **String Theory**: Compactified dimensions often modeled as tori
        • **Tokamak**: Plasma confinement for fusion uses toroidal magnetic fields

        Historical & Cultural Context:
        ------------------------------
        • **Ancient**: Symbol appears in Celtic knots, Norse cosmology (Yggdrasil)
        • **Renaissance**: Kepler studied torus as wine barrel optimization
        • **18th Century**: Euler's polyhedral formula extended to torus (χ=0)
        • **19th Century**: Gauss studied intrinsic curvature of surfaces
        • **20th Century**: Topology revolution (Poincaré, Betti numbers)
        • **Modern**: Phase space topology, dynamical systems attractors

        In Art & Architecture:
        • **Sculpture**: Henry Moore, Anish Kapoor ("Cloud Gate" approximates torus)
        • **Architecture**: Toroidal buildings for optimal structural strength
        • **Sacred Geometry**: Represents the flow of universal energy (torus field)
        • **Music**: Phase space of coupled oscillators (rhythm/harmony)

        In Physics & Engineering:
        • **Electromagnetism**: Toroidal coils (transformers, inductors)
        • **Fluid Dynamics**: Vortex rings (smoke rings, dolphin bubble rings)
        • **Plasma Physics**: Tokamak fusion reactors
        • **Cosmology**: Proposed topology for universe (multiply-connected space)

        References:
        -----------
        [1] Willmore, T.J. (1993). Riemannian Geometry. Oxford University Press.
        [2] do Carmo, M. (1976). Differential Geometry of Curves and Surfaces.
        [3] Berger, M. (2009). Geometry Revealed. Springer.
        [4] Gray, A. (1997). Modern Differential Geometry of Curves and Surfaces.
        [5] Thurston, W. (1997). Three-Dimensional Geometry and Topology.
        [6] Weeks, J. (2002). The Shape of Space, 2nd ed. CRC Press.
        """
        return TorusMetrics(
            major_radius=R,
            minor_radius=r,
            ratio=R/r if r > 0 else 0,
            surface_area=4 * (math.pi ** 2) * R * r,
            volume=2 * (math.pi ** 2) * R * (r ** 2),
            major_circumference=2 * math.pi * R,
            minor_circumference=2 * math.pi * r,
        )

    @staticmethod
    def _generate_mesh(R: float, r: float, config: TorusMeshConfig) -> Tuple[List[Vec3], List[Tuple[int, ...]]]:
        vertices = []
        faces = []
        
        div_u = config.major_segments
        div_v = config.minor_segments
        
        # Generate vertices
        # u goes around the tube (minor angle)
        # v goes around the torus hole (major angle)
        # Wait, usually u=major, v=minor. Let's stick to standard conv:
        # phi (major) in [0, 2pi], theta (minor) in [0, 2pi]
        
        for i in range(div_u):
            major_angle = (i / div_u) * 2 * math.pi
            cos_major = math.cos(major_angle)
            sin_major = math.sin(major_angle)
            
            for j in range(div_v):
                minor_angle = (j / div_v) * 2 * math.pi
                cos_minor = math.cos(minor_angle)
                sin_minor = math.sin(minor_angle)
                
                # Formula:
                # x = (R + r*cos(theta)) * cos(phi)
                # y = (R + r*cos(theta)) * sin(phi)
                # z = r * sin(theta)
                
                # Using Y as UP axis?
                # Usually in this app Y is UP? Let's check cube.
                # Cube: (-1, -1, -1) to (1, 1, 1). 
                # Let's assume Z is UP for geometry, or Y? 
                # Let's verify standard orientation. Usually standard math Z is up.
                # But implementation might vary. Let's assume Z is UP.
                
                x = (R + r * cos_minor) * cos_major
                y = (R + r * cos_minor) * sin_major
                z = r * sin_minor
                
                vertices.append((x, y, z))

        # Generate Faces (Quads)
        for i in range(div_u):
            next_i = (i + 1) % div_u
            for j in range(div_v):
                next_j = (j + 1) % div_v
                
                # Indices in the flat list
                # current vertex = i * div_v + j
                
                idx_bl = i * div_v + j           # Bottom Left
                idx_br = next_i * div_v + j      # Bottom Right
                idx_tr = next_i * div_v + next_j # Top Right
                idx_tl = i * div_v + next_j      # Top Left
                
                # Winding order? Let's try CCW
                faces.append((idx_bl, idx_br, idx_tr, idx_tl))

        return vertices, faces


class TorusSolidCalculator:
    """Bidirectional torus calculator."""

    def __init__(self, major_radius: float = 3.0, minor_radius: float = 1.0):
        """
          init   logic.
        
        Args:
            major_radius: Description of major_radius.
            minor_radius: Description of minor_radius.
        
        """
        self._properties = {
            'major_radius': SolidProperty('Major Radius (R)', 'major_radius', 'units', 10.0), # Priority 10 -> Input
            'minor_radius': SolidProperty('Minor Radius (r)', 'minor_radius', 'units', 10.0),
            'ratio': SolidProperty('Ratio (R/r)', 'ratio', '', 5.0),
            'surface_area': SolidProperty('Surface Area', 'surface_area', 'units²', 5.0),
            'volume': SolidProperty('Volume', 'volume', 'units³', 5.0),
            'major_circumference': SolidProperty('Major Circumference', 'major_circumference', 'units', 5.0),
            'minor_circumference': SolidProperty('Minor Circumference', 'minor_circumference', 'units', 5.0),
        }
        
        # Set initial values
        self.set_property('major_radius', major_radius)
        self.set_property('minor_radius', minor_radius)
        self._recalculate()

    def properties(self) -> List[SolidProperty]:
        """
        Properties logic.
        
        Returns:
            Result of properties operation.
        """
        return list(self._properties.values())

    def set_property(self, key: str, value: Optional[float]) -> bool:
        """
        Configure property logic.
        
        Args:
            key: Description of key.
            value: Description of value.
        
        Returns:
            Result of set_property operation.
        """
        if value is not None and value <= 0:
            return False
            
        prop = self._properties.get(key)
        if not prop:
            return False
            
        # Store input value
        prop.value = value
        
        # Bidirectional Resolving Logic
        # Try to solve for R and r
        R = self._properties['major_radius'].value
        r = self._properties['minor_radius'].value
        
        if key == 'major_radius':
            R = value
        elif key == 'minor_radius':
            r = value
        elif key == 'major_circumference':
            R = value / (2 * math.pi)  # type: ignore[reportConstantRedefinition, reportOptionalOperand, reportUnknownVariableType]
            self._properties['major_radius'].value = R
        elif key == 'minor_circumference':
            r = value / (2 * math.pi)
            self._properties['minor_radius'].value = r
        elif key == 'ratio':
            # Ratio = R / r. Need one of them to solve the other.
            # If we have R, r = R / ratio.
            ratio = value
            if R is not None:
                r = R / ratio
                self._properties['minor_radius'].value = r
            elif r is not None:
                R = r * ratio  # type: ignore[reportConstantRedefinition, reportOperatorIssue, reportUnknownVariableType]
                self._properties['major_radius'].value = R
        elif key == 'surface_area':
            # A = 4 pi^2 R r
            # Need ratio or fixed radius?
            # Creating a constraint solver is complex. 
            # Strategy: If R is set, solve for r. If r is set, solve for R. 
            # If neither, maybe assume Ratio=3? Or fail.
            pass 
        elif key == 'volume':
             # V = 2 pi^2 R r^2
             pass

        # If we successfully resolved R and r, update everything
        if R is not None and r is not None:
            self._properties['major_radius'].value = R
            self._properties['minor_radius'].value = r
            self._recalculate()
            return True
            
        return False

    def _recalculate(self):
        R = self._properties['major_radius'].value
        r = self._properties['minor_radius'].value
        
        if R is None or r is None:
            return

        metrics = TorusSolidService._compute_metrics(R, r)
        self._properties['ratio'].value = metrics.ratio
        self._properties['surface_area'].value = metrics.surface_area
        self._properties['volume'].value = metrics.volume
        self._properties['major_circumference'].value = metrics.major_circumference
        self._properties['minor_circumference'].value = metrics.minor_circumference
        
        self._result = TorusSolidService.build(R, r)

    def clear(self):
        """
        Clear logic.
        
        """
        for p in self._properties.values():
            p.value = None
        self._result = None

    def payload(self) -> Optional[SolidPayload]:
        """
        Payload logic.
        
        Returns:
            Result of payload operation.
        """
        return self._result.payload if self._result else None

    def metadata(self) -> Dict[str, float]:
        """
        Metadata logic.
        
        Returns:
            Result of metadata operation.
        """
        if not self._result:
            return {}
        return dict(self._result.payload.metadata)

    def metrics(self) -> Optional[TorusMetrics]:
        """
        Metrics logic.
        
        Returns:
            Result of metrics operation.
        """
        return self._result.metrics if self._result else None